# [4월 20일]

운영체제 개념정리를 하는데 참고사이트가 워낙 잘 정리된 글이라 동일하게 내용을 옮겨놓는게 맞나 싶다...

핵심만 잘 정리되어 있기에 동일하게 내용을 쓰면서 숙지하고 복습할 때 내용을 더 채우거나 수정을 해야겠다

***

1. 개념정리

- #### 동기화 문제

  > 동기화 : 한정적인 시스템 자원에 여러 스레드가 동시에 접근해서 사용하면 문제가 발생할 수 있음
  >
  > - 해결방안 : 여러 스레드에게 하나의 자원에 대한 처리 권한을 주거나 순서를 조정하는 기법을 사용

  - ##### 스레드 동기화

    1. 실행순서 동기화 : 스레드의 실행 순서를 정의하고, 이 순서를 반드시 따르도록 하는 것
    2. 메모리 접근에 대한 동기화
       - 메모리 접근에 있어서 동시 접근을 막는 것
       - 실행의 순서가 중요한 것이 아니라 한 순간에 하나의 스레드만 해당 자원에 접근하도록 하는 것

  - ##### 동기화 기법

    - 유저 모드의 동기화
      - 커널의 힘을 빌리지 않는 동기화 기법 (커널의 코드가 실행되지 않음)
      - 성능상 이점은 있으나 기능상의 제한점이 존재
      - 임계 구역 기반의 동기화
      - 인터락 함수 기반의 동기화
    - 커널 모드의 동기화
      - 커널에서 제공하는 동기화 기능을 이용하는 방법
      - 커널 모드로의 변경이 필요하고 이는 성능 저하로 이어짐
        - 그러나, 다양한 기능을 활용할 수 있음
        - 세마포어, 뮤텍스, 모니터 등등

  - ###### [유저모드 동기화]

    1. 임계 구역 기반의 동기화

       - 열쇠를 얻은 프로세스만 임계 구역에 들어갈 수 있음
         - 즉, 한번에 하나의 스레드만 접근 가능

       - 임계 구역 진입을 위해 크리티컬 섹션 오브젝트를 얻음

       - 다른 스레드가 열쇠를 가지고 있을 시에는 반환할 때까지 블로킹됨
         - 열쇠가 반환되면 블로킹 상태에서 빠져나와 열쇠를 얻고 임계 구역에 접근

    2. 인터락 함수 기반의 동기화
       - 함수 내부적으로 한 순간에 하나의 스레드에 의해서만 실행되도록 동기화
       - 임계 구역 기반의 동기화도 내부적으로 인터락 함수를 기반으로 구현
       - 유저 모드 기반으로 동작해서 속도가 빠름

  - ###### [커널모드 동기화]

    1. 세마포어
       - 공유된 자원의 데이터를 여러 프로세스, 스레드가 접근하는 것을 막음
       - 동시에 접근할 수 있는 '허용 가능한 갯수'를 가지고 있는 Counter
         - 1개 : Binary Semaphore
         - 2개 이상 : Counting Semaphore
       - 세마포어는 소유할 수 없음
         - 세마포어를 소유하지 않은 스레드가 세마포어를 해제할 수 있는 문제가 발생
    2. 뮤텍스
       - 공유된 자원의 데이터를 여러 프로세스, 스레드가 접근하는 것을 막음
       - 임계 구역을 가진 스레드들의 Running Time이 서로 겹치지 않게 각각 단독으로 실행되는 기술
       - **뮤텍스 객체를 두 스레드가 동시에 사용할 수 없음**
       - 일종의 Locking 매커니즘으로 공유 자원에 대한 접근을 조율하기 위해 locking과 unlocking을 사용
       - Lock에 대한 소유권이 있으며 Lock을 가지고 있을 경우에만 공유 자원에 접근할 수 있고,
         Lock을 가진 사람만 반납할 수 있음
       - 뮤텍스는 무조건 1개의 열쇠만 가질 수 있음
         열쇠를 가진 사람만이 화장실에 갈 수 있고, 다음 사람이 화장실에 가기 위해서는 앞 사람이 열쇠를 반납해야함
    3. 모니터
       - 뮤텍스(Lock)와 Condition Variables를 가지고 있는 Synchronization 매커니즘

    > **뮤텍스와 모니터는 상호 배제를 함으로써 임계 구역에 하나의 스레드만 들어갈 수 있음**
    >
    > **반면, 세마포어는 하나의 스레드만 들어가거나 혹은 여러 개의 스레드가 들어가게 할 수도 있음** 

  - 질문사항

    1. 임계영역

       - 둘 이상의 스레드가 동시에 접근해서는 안되는 공유 자원을 접근하는 코드의 일부

       - 임계 영역에서 동기화를 진행하지 못하면 치명적인 문제가 발생
       - 따라서 임계 구역 문제를 해결하기 위해서는 3가지 필수 조건이 있음
         1. 상호배제 : 프로세스 P1이 공유 자원을 접근하는 임계 구역 코드를 수행하고 있으면 다른 프로세스들은 공유 자원을 접근하는 임계 구역 코드를 수행할 수 없음.
            - 즉, 한 순간에 하나의 스레드만이 실행될 수 있음
         2. 진행 : 임계 구역에서 실행중인 프로세스가 없고 별도의 동작이 없는 프로세스들만 임계 구역 진입 후보로서 참여될 수 있음
         3. 한정된 대기 : P1이 임계 구역에 진입 신청 후부터 받아들여질때까지, 다른 프로세스들이 임계 구역에 진입하는 횟수는 제한이 있어야 함 (대기번호가 있다?)

    2. 뮤텍스와 모니터의 차이
       - 뮤텍스는 다른 프로세스나 스레드 간에 동기화를 위해 사용
       - 모니터는 하나의 프로세스내에서 다른 스레드 간에 동기화할 때 사용
       - 뮤텍스는 운영체제 커널에 의해 제공되기에, 무겁고 느림
       - 모니터는 프레임워크나 라이브러리 자체에서 제공되기에, 가볍고 빠름
    3. 세마포어와 모니터의 차이
       - 자바에서 모니터를 모든 객체에게 기본적으로 제공하지만 C에서는 사용할 수 없음
       - 세마포어는 카운터라는 변수 값으로 프로그래머가 상호 배제나 정렬의 목적으로 사용시 매번 값을 따로 지정해줘야하는 등 조금 번거로움이 있음
       - 반면, 모니터는 이러한 일들이 캡슐화되어 있어서 개발자는 카운터 값을 0 또는 1로 주어야 하는 고민을 할 필요가 없이 Synchronized, wait(), notify() 등의 키워드를 이용해 좀 더 편하게 동기화 할 수 있음

    4. 세마포어와 뮤텍스의 차이

       - 세마포어는 뮤텍스가 될 수 있지만, 뮤텍스는 세마포어가 될 수 없음
       - 세마포어는 소유할 수 없으며, 뮤텍스는 소유할 수 있고 소유주가 그 책임을 짐
       - 뮤텍스의 경우 뮤텍스를 소유하고 있는 스레드가 이 뮤텍스를 해제할 수 있음
       - **뮤텍스는 동기화 대상이 1개일 때 사용하고 세마포어는 동기화 대상이 여러 개 일때 사용**

       > **[화장실 상황에 비유]**
       >
       > - 뮤텍스 - 동기화 대상이 오직 하나
       >
       >   화장실을 이용할 때 키를 가지고 가야하는 상황과 유사
       >
       >   - 화장실은 1명만 이용 가능
       >
       >   - 열쇠가 사용 가능한 상태라면 열쇠를 가지고 화장실에서 용무를 해결할 수 있음
       >   - 열쇠가 사용 불가능한 상태라면 열쇠를 가진 사람이 용무가 끝나고 열쇠를 사용 가능한 상태로 바꾸기 전까지 대기를 하며 대기는 순서대로 이루어짐
       >
       > - 세마포어 - 동기화 대상이 여러 개
       >
       >   화장실이 여러 칸으로 구성되어 있는 상황과 유사
       >
       >   - 화장실은 여러 명이 사용 가능 (세마포어에서 카운트 지정)
       >   - 용무를 볼 수 있는 사람은 정해진 칸만큼의 사람이 용무를 볼 수 있음
       >   - 모든 칸에서 용무 중이라면 대기는 순서대로 이루어짐
       >   - 모든 칸이 용무 중이다가 한 사람이 나오면 대기 중이던 한사람이 용무를 보러 들어감

  - #### 요약

    - 뮤텍스 : 한 스레드, 프로세스에 의해 소유될 수 있는 Key를 기반으로 한 상호배제 기법

    - 세마포어 : 현재 공유자원에 접근할 수 있는 스레드, 프로세스의 수를 나타내는 값을 두어 상호배제를 달성하는 기법

    **뮤텍스와 세마포어의 목적은 특정 동기화 대상이 이미 특정 스레드나 프로세스에 의해 사용중일 경우, 다른 스레드가 해당 동기화 대상에 접근하는 것을 제한하는 것으로 동일하지만, 관리하는 동기화 대상이 몇개인가에 따라 차이가 생긴다.**

    두 기법 모두 완벽하지는 않다. 이 기법들을 사용하더라도 데이터 무결성을 보장할 수 없으며 데드락이 발생할 수도 있다. 하지만 상호배제를 위한 기본적인 기법이며 여기에 좀 더 복잡한 매커니즘을 적용해 꽤나 우아하게 동작하는 프로그램을 짤 수 있다고 한다.



***

2. 알고리즘

- BFS
  - 백준 - 1697번 🔥
    - Queue, Visited, Depth를 활용
      - Visited를 활용하여 방문 처리 확인
      - Depth를 활용하여 최소 방문 횟수 확인
      - Queue를 활용하여 원하는 목적지의 값이 몇번째에 있는지 확인
  
  - 백준 - 1260번 🔥🔥
  
    - BFS
      - 큐를 활용하여 원하는 값을 찾아냄
      - 방문처리 해야함
    - DFS
      - 방문처리만 해주면 됨
  
  - 백준 - 4963번 🔥🔥
  
    - 배열을 활용하여 좌표 이동할 모든 경우를 정리
  
      ```swift
      let dx = [-1, 1, 0, 0, -1, 1, -1, 1]
      let dy = [0, 0, -1, 1, -1, -1, 1, 1]
      ```
  
    - 이중 배열을 활용하여 섬의 위치를 입력
    - 2차원 좌표이기에 이중 For문을 활용하여 탐색 시작
    - 탐색 시작 후 섬 위치를 발견하면 좌표값을 변경하면서 DFS 탐색 시작
    - 탐색이 완료된 후 true를 확인한 다음 섬의 갯수 추가



***

