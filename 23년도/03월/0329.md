# [3월 29일]

### 1. 개념정리

- ##### ARC란 (Automatic Reference Counting)

  - 참조(레퍼런스) 메모리 관리를 자동으로 해주는 기능

  - 인스턴스가 참조 또는 참조 해제될 때마다 레퍼런스를 카운팅하고,

    레퍼런스 카운트가 0이 되면 인스턴스를 메모리에서 해제하는 방식으로 메모리를 관리



- ##### Retain Count 방식

  - 객체가 메모리에서 해제되지 않도록 이 함수를 호출하여 카운트를 증가시키는것



- ##### Strong 과 Weak 참조 방식

  - Strong
    - 인스턴스의 소유권을 가짐
    - 자신이 참조하는 인스턴스의 Retain Count를 증가
    - 값 지정 시점에 Retain이 되고, 참조가 종료되는 시점에 Release가 됨
    - 선언할 때 아무것도 적어주지 않으면 Default로 Strong이 됨
  - Weak
    - 해당 인스턴스의 소유권을 가지지 않고, 주소값만을 가지는 포인터 개념
    - 자신이 참조하는 인스턴스의 Retain Count를 증가시키지 않음
      - 즉, Release 또한 되지 않음
    - 자신이 참조는 하지만 Weak 메모리를 해제할 수 있는 권한은 다른 클래스에게 있음
    - 메모리가 해제될 경우 자동으로 레퍼런스가 nil로 초기화 됨
    - Weak 속성을 사용하는 객체는 항상 Optional타입이여야함 (객체가 nil일 수도 있기 때문)



- ##### 순환 참조

  - 두 가지 이상의 객체가 서로 Strong Reference(강한 참조) 상태를 가지고 있을 때 발생
    - 순환 참조가 발생하게 되면 
      - 서로에 대한 참조가 해제되지 않기 때문에 메모리에서 유지되며 이로 인해 메모리 릭이 발생함



- ##### 강한 순환 참조 (Strong Reference Cycle) 는 어떤 경우에 발생

  - 강한 순환 참조 : 여러 인스턴스가 서로 강한 참조를 하는 사이클을 생성하는 것

    - 발생하게 될 경우
      - Reference Count가 0 이 되지 않아 
        실제로 사용을 하지 않는 인스턴스가 메모리를 차지하고 있는 메모리 누수 현상이 발생

  - 발생하는 경우

    - 두 객체가 서로를 참조한 경우에 발생

    - 예제 코드

      ```swift
      class A { 
      	let instance : B?
        ...
      }
      
      class B {
      	let instance : A?
      	...    
      }
      ```

  - 해결방안

    - Weak
      - 참조하는 인스턴스의 Reference Count 를 증가시키지 않음
      - 참조하는 인스턴스가 메모리에서 할당 해제될 경우 `nil` 이 할당
      - 옵셔널타입으로 선언해줘야 함
    - Unowned
      - 참조하는 인스턴스의 Reference Count 를 증가시키지 않음
      - 참조하는 인스턴스가 메모리에서 할당 해제될 경우 `nil`이 되지 않고 `dangling pointer` 가 됨
      - 옵셔널타입으로 선언하지 않아도 됨



***

### 2. 알고리즘

- ##### 백트래킹
  
  - 백트래킹은 <u>"DFS 방법이지만, 어느정도의 depth에 도달하게 되면 탐색중지"</u>하는 알고리즘
- ##### 브루트 포스 - 재귀
  
  - 백준 - 2529번 🔥
    - 어렵다... 원하는 숫자만 거르도록 짜는게 어렵다...
      - 기호에 맞는 조건식을 짜주는게 핵심!
    - DFS의 개념을 조금 더 향상시키는데는 좋은 문제


- ##### 브루트 포스 - 비트마스크


    - 백준 - 11723번


        - 뭐지... 싶은 문제...
        - 구현은 쉬우나, 시간초과가 떠서 답안 확인해본 결과 리얼 비트계산? 이 필요했던 문제

            - Swift에서 구현하기 어려운 문제라고 나와있긴 하다...

        - 그러므로 일단 PASS!

    - 백준 - 1182번 🔥


        - 기본적인 DFS - 백트래킹 문제

        - 탈출식만 잘 정립하면 풀이가 가능

            ```swift
            private func dfs(depth: Int, start: Int) {
                [탈출 조건식]
              
                for i in start..<n {
                    if !visited[i] {
                        visited[i] = true
                      	[탈출 조건식 확인을 위한 계산]
                        dfs(depth: depth + 1, start: i)
                        visited[i] = false
                      	[탈출 조건식 확인을 위한 계산 원복]
                    }
                }
            }
            ```

    - 백준 - 14889번 🔥


        - 브루트 포스 - 재귀 유형에서도 풀이한 문제
        - DFS 구현을 통해 풀이 가능

          - 탈출 조건식이 까다로움

              - 팀을 반으로 나눈 시점을 알아내는 조건, 최소 차이값 구하기



- BFS & DFS 기본 개념 - https://didu-story.tistory.com/98



***

