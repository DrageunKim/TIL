# [3월 28일]

### 1. 개념 정리

- ##### defer

  - 현재 코드 블록을 나가기 전에 꼭 실행해야 되는 코드
  - 코드가 블록을 어떻게 빠져 나가든 꼭 마무리해야 되는 작업을 할 수 있게 도와주는 역할




- ##### defer가 호출되는 순서는 어떻게 되고, defer가 호출되지 않는 경우

  - 코드블록 순서로 호출되며, 같은 코드블럭일 경우 역순으로 호출
  - defer를 읽지 않고 return을 하는 경우 defer가 호출되지 않음
    - throw를 이용해서 오류를 던질 경우
    - guard 문을 사용하여 중간에 함수를 종료하는 경우
    - 리턴값이 Never(비반환함수)인 경우




- ##### property wrapper

  - 어떤 값이 있으면 이 값을 한 번 감싸서 저장을 위한 로직과 
    얻어오기 위한 로직을 어느정도 분리해서 반복을 줄여줄 수 있는 방법을 제공하는 속성
  - 중복되는 Get/Set 안의 로직들을 프로퍼티 자체에 연결할 수 있어 보일러플레이트 코드와 코드 재사용성을 높여줌
    - 반복되는 로직들을 프로퍼티 자체에 연결할 수 있다




- ##### Generic

  - 정의

    - 타입에 의존하지 않는 범용 코드를 작성할 때 사용
      - 제네릭을 사용하면 중복을 피하고, 코드를 유연하게 작성할 수 있음

  - 제네릭 함수

    - 타입에 제한을 두지 않는 코드를 사용하고 싶을 때 사용
      - `<T>`- Placeholder로 T는 새로운 타입이 아니기에 실제 이 타입을 찾지 않게 해주는 자리 타입

  - 제네릭  타입

    - 구조체, 클래스, 열거형 타입에 제네릭을 선언하여 사용할 수 있음
    - 제네릭 타입을 사용하게 될 경우 인스턴스 생성은 `<Int>`, `<Double>`과 같이 <>을 통해 타입을 명시
      - 배열 생성시 `Array<Int>`와 동일한 원칙

  - 프로토콜 제약

    - 제네릭 함수를 비교하는 코드를 작성할 경우 `<Equatable>` 프로토콜로 제약을 걸어 사용할 수 있음

      ```swift
      /* 에러가 발생하는 제네릭 함수의 예제 */
      func testSameValues<T>(a: T, b: T) -> Int {
          return a == b
      }
      
      /* 에러가 해결한 제네릭 함수의 예제 */
      func testSameValues<T: Equaatable>(a: T, b: T) -> Int {
          return a == b
      }
      ```

  - 클래스 제약

    - 프로토콜 제약과 동일하게 원하는 클래스만 받겠다는 제약을 거는 방식

  - 제네릭 확장

    - extension- `where`를 사용하여 기존 타입에 다른 타입을 받을 수 있도록 확장 또는 제약을 줄 수 있음




- ##### some 키워드

  - some키워드는 return값에 불투명한 타입이 있음을 나타냄
  - 불투명한 타입이란 어떠한 타입을 리턴할 지 모른다는 것을 의미
    - some키워드를 사용하면 함수 내부의 리턴 값에 따라 리턴 타입이 지정




- ##### Result타입

  - 정의
    - Generic Enumeration로 선언되어 있고, 경우에 따른 연관값을 포함하여, 성공/실패를 나타내는 값

  - 사용하는 이유
    - 일반 에러처리는 에러타입의 열거형 생성 -> 사용할 메서드 생성에 에러 지정 -> do-catch-try를 통해 에러 처리하는 3단계를 거침
      - 위 방식의 단점은 사용할 메서드에서 에러 처리를 어떻게 했는지 한눈에 알기 어려움
      - Result타입을 사용함으로써, Success & Failure 되는 위치를 한눈에 알 수 있음




- ##### Codable

  - Encodable + Decodable이 합쳐진 프로토콜
    - Encodable - 특정한 모델을 Data로 변환해주는 것
    - Decodable - Data를 특정한 모델로 변환해주는 것




- ##### Closure

  - 정의
    - 참조타입으로 일정 기능을 수행하는 코드의 블럭을 뜻하며 일급 객체의 역할을 할 수 있음
      - 일급객체란 - 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체
      - 일급객체의 조건
        - 변수에 저장할 수 있어야 한다.
        - 객체(함수)의 인자로 전달할 수 있어야 한다.
        - 객체(함수)의 리턴값으로 사용할 수 있어야 한다.

  - 장점
    - 전역변수를 줄일 수 있음
      - 함수가 종료된 후 동작을 처리해줄 때, 전역변수를 사용하지 않고 탈출 클로져안에서 변수를 생성하여 동작을 정의해줄 수 있음

    - 비슷한 형태의 코드를 재사용률을 높일 수 있음




- ##### Closure와 함수와의 관계

  - Closure는 2가지 타입이 존재
    - Named Closure - 이름 있는 클로저로 일반적인 함수가 이에 해당
    - Unnamed Closure - 이름이 없는 익명 함수로 일반적으로 클로저라 부르는 것이 이것에 해당



- 나중에 보면 좋을 글
  - https://www.wanted.co.kr/events/22_11_s01_b15?utm_source=wanted&utm_medium=share




***

### 2. 알고리즘

- 브루트 포스 - 재귀
  - 백준 - 9095번 ⭐️
    - 다이나믹 프로그래밍, 기본 브루트포스, 순열 브르투포스 3종류에서 나온 문제...
    - 이전과 동일하게 DP를 활용하여 풀이하였지만... 잘 기억해둬야겠다!
  
  - 백준 - 14501번 🔥
  
    - 재귀 유형이 DP와 유사한 것 같다 DP로 풀이가 가능했다
    - 배열을 생성하여 일정소요 후 값이 입력되도록 구현하여 최종 값에 있는 값을 가져오도록 구현
  
  - 백준 - 14889번
  
    - DFS 문제로 DFS 구현코드를 이용하면 풀이 가능
  
    - DFS 구현코드를 외워두자!
  
      ```swift
      /* DFS - 예제 구현 코드 */
      private func dfs(depth: Int, start: Int) {
          [탈출 조건식]
        
          for i in start..<n {
              if !visited[i] {
                  visited[i] = true
                  dfs(depth: depth + 1, start: i)
                  visited[i] = false
              }
          }
      }
      ```



***

### 3. 코드 팩토링

- Core Data
  - 개념
    - Database가 아니며, 데이터를 유지하기 위한 API도 아님
    - 넓은 의미로 앱의 모델 계층이며, 객체 그래프를 관리하는 Framework
  - 사용 순서
    - NSManagerdObjectContext로 Persistent Container를 생성한다.
    - View Controller에 생성한 Persistent Container를 전달한다.
    - Entity를 가지고 온다.
    - NSManagedObject를 만든다
    - NSManagedObjectContext에 저장한다.
    - 잘 저장되었는지 앱을 종료하고 확인해본다